<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
<title>PDF Viewer with Embedded Bookmarks</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100vh;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #toolbar {
    position: fixed;
    top: 5px;
    left: 5px;
    background: rgba(255 255 255 / 0.9);
    padding: 8px;
    border-radius: 8px;
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 10px;
    backdrop-filter: blur(5px);
  }
  #bookmark-input { 
    display: none;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  #viewerContainer {
    position: fixed;
    top: 50px;
    bottom: 0;
    left: 0;
    right: 0;
    overflow-y: scroll;
    -webkit-overflow-scrolling: touch;
    background: #ddd;
  }
  canvas.pageCanvas {
    display: block;
    margin: 8px auto;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    max-width: 90vw;
    height: auto !important;
    user-select: none;
    border-radius: 4px;
  }
  #bookmark-list {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(255 255 255 / 0.95);
    max-height: 200px;
    overflow-y: auto;
    padding: 10px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 1000;
    width: 280px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.3);
  }
  #bookmark-list strong { 
    display: block; 
    margin-bottom: 8px; 
    color: #333;
    font-size: 16px;
  }
  #bookmark-list div { 
    margin-bottom: 5px; 
    cursor: pointer; 
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.2s;
  }
  #bookmark-list div:hover {
    background: rgba(0,123,255,0.1);
  }
  #download-btn {
    background: #007bff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
  #download-btn:hover {
    background: #0056b3;
  }
  #download-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }
  #file-input {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  .status {
    font-size: 12px;
    color: #666;
    margin-left: 10px;
  }
</style>
</head>
<body>

<div id="toolbar">
  <input type="file" id="file-input" accept="application/pdf" />
  <button id="download-btn" disabled>Download with Bookmarks</button>
  <span>Press Cmd+D to bookmark current page</span>
  <input type="text" id="bookmark-input" placeholder="Enter bookmark name" />
  <span class="status" id="status"></span>
</div>

<div id="viewerContainer"></div>

<div id="bookmark-list">
  <strong>Bookmarks:</strong>
  <div id="bookmarks"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.9.179/build/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script>
window.addEventListener('DOMContentLoaded', () => {
  const pdfjsLib = window.pdfjsLib;
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.9.179/build/pdf.worker.min.js';

  const fileInput = document.getElementById('file-input');
  const viewerContainer = document.getElementById('viewerContainer');
  const bookmarkInput = document.getElementById('bookmark-input');
  const bookmarksDiv = document.getElementById('bookmarks');
  const downloadBtn = document.getElementById('download-btn');
  const statusSpan = document.getElementById('status');

  let pdfDoc = null;
  let originalPdfArrayBuffer = null;
  let bookmarks = [];
  let pageCanvases = {};
  let pageRenderQueue = [];
  let cachedBookmarkedPdfUrl = null;
  let fileName = 'bookmarked.pdf';

  const scale = 1.3;

  function setStatus(message) {
    statusSpan.textContent = message;
    console.log('Status:', message);
  }

  async function renderPage(pageNum) {
    if (pageCanvases[pageNum]) return;
    
    try {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      canvas.className = 'pageCanvas';
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      canvas.setAttribute('data-page-number', pageNum);
      
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      
      pageCanvases[pageNum] = canvas;
      viewerContainer.appendChild(canvas);
    } catch (error) {
      console.error(`Error rendering page ${pageNum}:`, error);
    }
  }

  function renderNextPageInQueue() {
    if (pageRenderQueue.length === 0) return;
    
    const nextPage = pageRenderQueue.shift();
    renderPage(nextPage).then(() => {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(renderNextPageInQueue);
      } else {
        setTimeout(renderNextPageInQueue, 50);
      }
    }).catch(error => {
      console.error('Error in render queue:', error);
      renderNextPageInQueue(); // Continue with next page
    });
  }

  async function loadAllPages() {
    viewerContainer.innerHTML = '';
    pageCanvases = {};
    pageRenderQueue = [];
    
    for (let i = 1; i <= pdfDoc.numPages; i++) {
      pageRenderQueue.push(i);
    }
    
    setStatus(`Loading ${pdfDoc.numPages} pages...`);
    renderNextPageInQueue();
  }

  function getCurrentVisiblePage() {
    const scrollTop = viewerContainer.scrollTop;
    const viewportHeight = viewerContainer.clientHeight;
    const centerY = scrollTop + viewportHeight / 2;
    
    let closestPage = 1;
    let closestDistance = Infinity;
    
    Object.values(pageCanvases).forEach(canvas => {
      const pageNum = Number(canvas.getAttribute('data-page-number'));
      const pageTop = canvas.offsetTop;
      const pageBottom = pageTop + canvas.height;
      const pageCenter = pageTop + canvas.height / 2;
      
      // Check if center of viewport is within this page
      if (centerY >= pageTop && centerY <= pageBottom) {
        closestPage = pageNum;
        return;
      }
      
      // Otherwise find closest page
      const distance = Math.abs(pageCenter - centerY);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestPage = pageNum;
      }
    });
    
    return closestPage;
  }

  // Keyboard shortcut for bookmarking
  window.addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'd') {
      e.preventDefault();
      if (!pdfDoc) {
        alert('Please load a PDF first');
        return;
      }
      
      bookmarkInput.style.display = 'inline-block';
      bookmarkInput.value = '';
      bookmarkInput.focus();
    }
  });

  // Handle bookmark input
  bookmarkInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const name = bookmarkInput.value.trim();
      if (name) {
        const page = getCurrentVisiblePage();
        const existingIndex = bookmarks.findIndex(b => b.page === page);
        
        if (existingIndex >= 0) {
          bookmarks[existingIndex].name = name;
          setStatus(`Updated bookmark for page ${page}`);
        } else {
          bookmarks.push({ page, name });
          setStatus(`Added bookmark for page ${page}: ${name}`);
        }
        
        renderBookmarks();
        bookmarkInput.style.display = 'none';
      }
    } else if (e.key === 'Escape') {
      bookmarkInput.style.display = 'none';
    }
  });

  async function renderBookmarks() {
    bookmarksDiv.innerHTML = '';
    
    // Sort bookmarks by page number
    bookmarks.sort((a, b) => a.page - b.page);
    
    bookmarks.forEach((bookmark, index) => {
      const bookmarkEl = document.createElement('div');
      bookmarkEl.innerHTML = `
        <span>Page ${bookmark.page}: ${bookmark.name}</span>
        <button onclick="removeBookmark(${index})" style="float: right; background: #dc3545; color: white; border: none; border-radius: 2px; padding: 2px 6px; cursor: pointer;">Ã—</button>
      `;
      
      bookmarkEl.onclick = (e) => {
        if (e.target.tagName !== 'BUTTON') {
          const canvas = pageCanvases[bookmark.page];
          if (canvas) {
            viewerContainer.scrollTo({ 
              top: canvas.offsetTop - 50, 
              behavior: 'smooth' 
            });
          }
        }
      };
      
      bookmarksDiv.appendChild(bookmarkEl);
    });
    
    // Update cached PDF with bookmarks
    await updateCachedPdf();
  }

  // Global function for removing bookmarks
  window.removeBookmark = (index) => {
    if (index >= 0 && index < bookmarks.length) {
      const removed = bookmarks.splice(index, 1)[0];
      setStatus(`Removed bookmark: ${removed.name}`);
      renderBookmarks();
    }
  };

  async function updateCachedPdf() {
    if (!originalPdfArrayBuffer) {
      downloadBtn.disabled = true;
      return;
    }

    downloadBtn.disabled = true;
    setStatus('Generating PDF with bookmarks...');

    try {
      // Create a copy of the original array buffer
      const pdfBytes = new Uint8Array(originalPdfArrayBuffer);
      
      // Load the PDF with pdf-lib
      const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
      
      if (bookmarks.length > 0) {
        // Create outline (bookmark tree)
        const outlineRef = pdfDoc.context.nextRef();
        const outlineDict = pdfDoc.context.obj({
          Type: 'Outlines',
          Count: bookmarks.length,
        });

        // Create bookmark items
        const bookmarkRefs = [];
        const bookmarkDicts = [];

        for (let i = 0; i < bookmarks.length; i++) {
          const bookmark = bookmarks[i];
          const bookmarkRef = pdfDoc.context.nextRef();
          bookmarkRefs.push(bookmarkRef);

          // Get the page reference (pdf-lib pages are 0-indexed)
          const pages = pdfDoc.getPages();
          const pageIndex = bookmark.page - 1;
          
          if (pageIndex >= 0 && pageIndex < pages.length) {
            const page = pages[pageIndex];
            
            const bookmarkDict = pdfDoc.context.obj({
              Title: PDFLib.PDFString.of(bookmark.name),
              Parent: outlineRef,
              Dest: [page.ref, 'XYZ', null, null, null],
            });

            // Set up next/prev relationships
            if (i > 0) {
              bookmarkDict.set('Prev', bookmarkRefs[i - 1]);
            }
            if (i < bookmarks.length - 1) {
              bookmarkDict.set('Next', pdfDoc.context.nextRef());
              bookmarkRefs[i + 1] = bookmarkDict.get('Next');
            }

            bookmarkDicts.push(bookmarkDict);
          }
        }

        // Set first and last in outline
        if (bookmarkRefs.length > 0) {
          outlineDict.set('First', bookmarkRefs[0]);
          outlineDict.set('Last', bookmarkRefs[bookmarkRefs.length - 1]);
        }

        // Register all objects
        pdfDoc.context.assign(outlineRef, outlineDict);
        bookmarkRefs.forEach((ref, i) => {
          if (bookmarkDicts[i]) {
            pdfDoc.context.assign(ref, bookmarkDicts[i]);
          }
        });

        // Add outline to document catalog
        const catalog = pdfDoc.catalog;
        catalog.set('Outlines', outlineRef);
      }

      // Save the modified PDF
      const modifiedPdfBytes = await pdfDoc.save();
      const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });

      // Clean up previous URL
      if (cachedBookmarkedPdfUrl) {
        URL.revokeObjectURL(cachedBookmarkedPdfUrl);
      }

      cachedBookmarkedPdfUrl = URL.createObjectURL(blob);
      downloadBtn.disabled = false;
      
      setStatus(`PDF ready with ${bookmarks.length} bookmark(s)`);

    } catch (error) {
      console.error('Error creating bookmarked PDF:', error);
      setStatus('Error creating bookmarked PDF');
      downloadBtn.disabled = true;
      cachedBookmarkedPdfUrl = null;
    }
  }

  // File input handler
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file || file.type !== 'application/pdf') {
      alert('Please select a PDF file.');
      return;
    }

    fileName = file.name.replace('.pdf', '_bookmarked.pdf');
    setStatus('Loading PDF...');

    const fileReader = new FileReader();
    fileReader.onload = async function() {
      try {
        // Store original PDF data
        originalPdfArrayBuffer = this.result;
        
        // Load with PDF.js for viewing
        pdfDoc = await pdfjsLib.getDocument({
          data: new Uint8Array(originalPdfArrayBuffer),
          cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.9.179/cmaps/',
          cMapPacked: true,
        }).promise;
        
        // Reset bookmarks
        bookmarks = [];
        await renderBookmarks();
        await loadAllPages();
        
        setStatus(`Loaded PDF with ${pdfDoc.numPages} pages`);
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        alert('Error loading PDF: ' + error.message);
        setStatus('Error loading PDF');
      }
    };
    
    fileReader.readAsArrayBuffer(file);
  });

  // Download button handler
  downloadBtn.addEventListener('click', () => {
    if (!cachedBookmarkedPdfUrl) {
      alert('No bookmarked PDF ready. Add bookmarks first.');
      return;
    }

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (isIOS) {
      // On iOS, open in new tab
      window.open(cachedBookmarkedPdfUrl, '_blank');
    } else {
      // On other platforms, trigger download
      const a = document.createElement('a');
      a.href = cachedBookmarkedPdfUrl;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    
    setStatus('PDF downloaded');
  });

  // Initial status
  setStatus('Ready - Load a PDF to get started');
});
</script>
</body>
</html>
